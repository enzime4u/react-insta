{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _parser = require(\"./parser\");\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Processor = function () {\n  function Processor(func, options) {\n    _classCallCheck(this, Processor);\n\n    this.func = func || function noop() {};\n\n    this.funcRes = null;\n    this.options = options;\n  }\n\n  Processor.prototype._shouldUpdateSelector = function _shouldUpdateSelector(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var merged = Object.assign({}, this.options, options);\n\n    if (merged.updateSelector === false) {\n      return false;\n    } else {\n      return typeof rule !== \"string\";\n    }\n  };\n\n  Processor.prototype._isLossy = function _isLossy() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var merged = Object.assign({}, this.options, options);\n\n    if (merged.lossless === false) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  Processor.prototype._root = function _root(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var parser = new _parser2.default(rule, this._parseOptions(options));\n    return parser.root;\n  };\n\n  Processor.prototype._parseOptions = function _parseOptions(options) {\n    return {\n      lossy: this._isLossy(options)\n    };\n  };\n\n  Processor.prototype._run = function _run(rule) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise(function (resolve, reject) {\n      try {\n        var root = _this._root(rule, options);\n\n        Promise.resolve(_this.func(root)).then(function (transform) {\n          var string = undefined;\n\n          if (_this._shouldUpdateSelector(rule, options)) {\n            string = root.toString();\n            rule.selector = string;\n          }\n\n          return {\n            transform: transform,\n            root: root,\n            string: string\n          };\n        }).then(resolve, reject);\n      } catch (e) {\n        reject(e);\n        return;\n      }\n    });\n  };\n\n  Processor.prototype._runSync = function _runSync(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var root = this._root(rule, options);\n\n    var transform = this.func(root);\n\n    if (transform && typeof transform.then === \"function\") {\n      throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n    }\n\n    var string = undefined;\n\n    if (options.updateSelector && typeof rule !== \"string\") {\n      string = root.toString();\n      rule.selector = string;\n    }\n\n    return {\n      transform: transform,\n      root: root,\n      string: string\n    };\n  };\n  /**\n   * Process rule into a selector AST.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n   */\n\n\n  Processor.prototype.ast = function ast(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.root;\n    });\n  };\n  /**\n   * Process rule into a selector AST synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {parser.Root} The AST of the selector after processing it.\n   */\n\n\n  Processor.prototype.astSync = function astSync(rule, options) {\n    return this._runSync(rule, options).root;\n  };\n  /**\n   * Process a selector into a transformed value asynchronously\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {Promise<any>} The value returned by the processor.\n   */\n\n\n  Processor.prototype.transform = function transform(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.transform;\n    });\n  };\n  /**\n   * Process a selector into a transformed value synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {any} The value returned by the processor.\n   */\n\n\n  Processor.prototype.transformSync = function transformSync(rule, options) {\n    return this._runSync(rule, options).transform;\n  };\n  /**\n   * Process a selector into a new selector string asynchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {string} the selector after processing.\n   */\n\n\n  Processor.prototype.process = function process(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.string || result.root.toString();\n    });\n  };\n  /**\n   * Process a selector into a new selector string synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {string} the selector after processing.\n   */\n\n\n  Processor.prototype.processSync = function processSync(rule, options) {\n    var result = this._runSync(rule, options);\n\n    return result.string || result.root.toString();\n  };\n\n  return Processor;\n}();\n\nexports.default = Processor;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}